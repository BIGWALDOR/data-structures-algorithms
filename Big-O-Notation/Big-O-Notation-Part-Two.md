# Big O Notation: Part Two

## Summary

- Big O notation is introduced as a formal way to describe the growth of algorithm runtime as inputs increase.

- It focuses on the broad trends and disregards specific details.

- Big O notation represents the relationship between the input size and the runtime of a function.

- Different notations exist, such as linear, quadratic, constant, and others.

- Big O notation considers the worst-case scenario and represents the upper bound for runtime.

- Examples are given to illustrate different big O complexities: O(1), O(N), and O(N^2).

- The complexity O(N) represents linear growth, O(1) represents constant time, and O(N^2) represents quadratic growth.

- The performance of algorithms can be visualized on a chart to observe the growth patterns.

- The complexity of an algorithm is determined by the dominant term in the expression.

- Understanding big O notation is important for assessing algorithm efficiency and scalability.

See: [Performance Tracker Tool](https://rithmschool.github.io/function-timer-demo/)
